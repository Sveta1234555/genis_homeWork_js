//----------------------------
//----------------------------
// js mod27
// -  ES6
//----------------------------
//----------------------------

// практическая задача, связазнная с html-----------------------
// кружочки - прятать и показывать

class CircleBox {
  //конструктор принимает selector
  // .. вызвается яавтоматически  при запуске компонента
  constructor(selector) {
    //инииализируем опции
    // В главный CirscleBox будем прокидвать только selector
    //потом сделаем много разных крожков

    // по соглашению конвенции между программистами, когда передаем селектор, передаем его через символ $
    this.$el = document.querySelector(selector);
  }
  hide() {
    this.$el.style.display = "none";
  }
  show() {
    this.$el.style.display = "block";
  }

  //в этом блоке делаем 2 метода, которые будут показывать и прятать кружочки
}

//от него, если мы решили сдлеать класс сначла больший , потом меньший..
// чтобы мы еще раз проговорили и повторили наследование в классах

// когда наследуем от первого класса еще один класс (а не объект)
// наследуем класс CircleItem от класса  CircleBox- пишем слово extends
class CircleItem extends CircleBox {
  constructor(options) {
    //если наследуем класс от другого класса , должен быть в консорукторе super
    //сюда надо прокинуть- передать selector
    super(options.selector);
    //навешивать стили, css небольшой здесь пропишам
    //ширину
    this.$el.style.width = options.size + "px";
    //т.к. это круг - то один раз прорпишем size  и на высоту и на ширину
    this.$el.style.height = options.size + "px";
    //можно будет поиграть с w h - Длеать овальными, квадратами ...
    //border radius стабильный для всех пропишем
    //потом можно поменять будет
    this.$el.style.borderRadius = "50%";
    //цвет
    this.$el.style.background = options.color;
  }
}

//делаем собственно круг, объект
//через оператор new, наследуем от CircleItem
// круглые объектные скобки
const CircleRed = new CircleItem({
  //здесь надо прописать стили , которые передаем для кружка
  // id  делаем по тому же названию, но с малю буквы
  // в html делаем div "    <div id="circleRed"></div>", т.е.. привязали id
  selector: "#circleRed",
  //привязать высоту и цвет (передаем как строку , в кавычках)
  color: "red",
  size: 50,
});

// 07:55 мин
// нарисовался кружок  7 - circle.png;

// ПРописываем ф-ции hide show  выше class CircleBox

//еще кружочки делаем
//в index
//   <div id="circleGreen"></div>
//   <div id="circleBlue"></div>

const CircleGreen = new CircleItem({
  //здесь надо прописать стили , которые передаем для кружка
  // id  делаем по тому же названию, но с малю буквы
  // в html делаем div "    <div id="circleRed"></div>", т.е.. привязали id
  selector: "#circleGreen",
  //привязать высоту и цвет (передаем как строку , в кавычках)
  color: "green",
  size: 80,
});

const CircleBlack = new CircleItem({
  //здесь надо прописать стили , которые передаем для кружка
  // id  делаем по тому же названию, но с малю буквы
  // в html делаем div "    <div id="circleRed"></div>", т.е.. привязали id
  selector: "#circleBlack",
  //привязать высоту и цвет (передаем как строку , в кавычках)
  color: "black",
  size: 30,
});

// 09:35 мин
// 3кружочка есть 7-circle3.png
// написаны ф-ции hide show - проверяем их
// пишем в ф12 в закл console
// CircleBlack.hide();   - спрятался черный кружок  см.CircleBlack_hide.png;
// CircleBlack.show();   -CircleBlack_show.png;

// т.е. класс  class CircleItem наследовал от класса class CircleBox все методы (hide show)
// и прокидывает их в следующие создаваемые объекты const CircleBlack...
//эти методы ненадо специально передавать  объявлять, они сами наследуются в объектах
// мы методы класса наследумого базового просто используем в объектах,
// Т.е. можем из объекта дотягиваться до любого метода из класса родителя базового.

//это было про расммотреть наследование примерчик

// 10:54 мин
//============================
// будем добавлять функции иначе
// через прототипы
// такое делали . На закрепление

function Car(name, color) {
  this.name = name;
  this.color = color;
}

//добавляем методы через прототип
//функцию message - выводить строчку
Car.prototype.message = function () {
  console.log(`${this.name} is ${this.color} color`);
};
// сделали машины  , объекты
const BMW = new Car("bmw", "red");
const opel = new Car("opel", "green");

BMW.message(); //bmw is red color
opel.message(); //opel is green color

//или проверка - в закл.консоль ф12 пишем:
// BMW.message()  //bmw is red color
// opel.message()  //opel is green color
// 7-2car_.png
// 7-2car_prototype.png

// т.е.с пом.метода prototype добавили метод в корень (глобальный верхний родительский класс, функцию...)
// чтобы не прокидывыать его каждому дочернему.

// добавим еще ф-цию туда же в корекнь
Car.prototype.start = function () {
  console.log(`${this.name} is start!!!`);
};

BMW.start(); //bmw is start!!!

//т.е. можно прокидывать ф-ции в объект наследующий способами
//1. из примера1 circle
//2. добавлять в прототипы
//3. можно setter   getter

// 15:08 мин
//======================
//миксины
// простой способ создать объект с полезными методами
// потом передать через прототип в объект
// переиспользовать

//делаем миксин

//ф-ция
let message = {
  // миксины:
  messageHello() {
    console.log(`Hello, ${this.name}`);
  },
  messageBye() {
    console.log(`Bye, ${this.name}`);
  },
};

class User {
  constructor(name) {
    this.name = name;
  }
}
//есть User, есть миксины, могуть быть другие классы
// Можем ф-ци message переиспользовать в других классах

//чтобы не переписывать сюда код message? пишем так:
Object.assign(User.prototype, message);
// User - кому
// message - что

//создаем User и вызывам метод messageHello  из message
new User("Иван").messageHello(); //Hello, Иван

//т.е. миксин можно с пом. метода "Object.assign"
// даже не в классе прописывать
// а вне класса прописывать
// использоаать.
// Потом можно использовать этот миксин в ругих классах, с инишими персонами...

// 18:15 мин
//================================================
// см.7тблЦветная.png
//javaScript развивается постоянно, доб-ся новые методы, не всеми инструментами поддерживаемые
// Таблица цветная - какие мктоды где поддерживаются
// (есть и браузеры десктопные, и мобильные версии)
// Все, что нужно для разраотки
// http://kangax.github.io/compat-table/es6/   - не открылось
//слева вниз - списк функций, для классов, для array и т.д.
//Смотрии, поддерживается ли это везде

//Существуют 2 иснтрумена:
// транспиляторы и полифилы
//==================
// транспиляторы; - специнструменты, кот переводит код из одного языка программирования на другую
// или о одной спецификации на другую
//Пример  -в javascript 20г. в обновленной версии вышла возможность
// синтакса:

height = height ?? 100;
// на старой спецификации это бы выглядело вот так:
height = height !== undefined && height !== null ? height : 100;
//но не все движки могут это новое оборабоаать
//ПОэтомку транспилятор проанализирует такой код и перепишет его
// один из известнецших траснпилятро - bubbl

//или если собираете проект через webpack (допоонительный автоматичесакий запуск)
// таи бываю часто уже вшиты транспиляторы

//==================
// полифилы
// 21:00мин
// В функиыонале могут быть нетолько синтасичсекие конструкции, операторы.
//   могут быть еще встроенные функици.
//   Напрмер,ф - я math
// Math.trunc;
// Она в старых версиях не работает.
// при запуске на старых движках  код упадет, не отработает
// Поэтому делаем полифилы. проверяем через if

// if (!Math.trunc)   //Если такой ф-ции нет
// тогда делаем ф-цию сами, руками пишем, что надо сделать

// это и есть полифил

//polyfill.io
//- не открылось
// классный сервис. Генерирует скрипт с полифилом
// в  зависимости от необходимых нам ф - ций и браузероы
// Это не значит что ненадо изучать современный функционал языка
// и использовать только старые версии, т.к.они поддерживаются.Нет.
// Надо не забывать использовать транспиляторы или полифилы.

// когда позднее будем рассматривать разные системы сборки , наприм. webpack
// тогда просто можно поставить плагин buble-loader
// и будет все ок

///-----
// https://habr.com/ru/companies/usetech/articles/687288/
// комментах:
// А вот тут самое главное: НЕ ПИШИТЕ СВОИ ПОЛИФИЛЫ. Для 99% подойдет core-js.
// Вместе с babel - env он умеет определять что используется в вашем коде
// и что нужно под какие - то браузеры
// и самостоятельно их расставлять и tree shake.
// И эта библиотека оттестирована миллионами разработчиков и миллиардами пользователей.
// Хуже того-- даже если там и есть ошибка, все остальные библиотеки используют core - js и работают с учетом этой ошибки и могут падать на вашем полифиле.
///-----

// Еще для браузерных ф - ций ссылка:
// caniuse.com  - открылся
//можно проверять свои браузерные ф-ции - будут ли они работать

// ..-----------------------------------------------------------
//22:58 мин
// комментарии в коде
// Надо комментировать код, особенно пока учимся.
// В дальнейшем - комментирвоат надо только сложные ф - ции, где сложно поянть, почему именно так.
// Обычно описываем в коде - почему именно так работает.
// но етсь такое правило "код долже быть читабельным и очевидным"
// Если ф-цию надо пояснять , то может стоит ее переписать так, тобы ненадо было комментировать
// Иногда  таки надо что-то пояснить
// при поддержании старого своего же кода, начинаем переписывать неоптимальное позже, и что-то валится
// Вспоминаем, что написали тогда именно так, потому что лучший метод тут бы не работал
// и если бы тогда здесь себе оставили коммент, почему именно так написано и работает,  не иначе
// не затратили бы столько времени сегодня.
//
// Как правильно комментировать код.
// пример -ф-я
// проверка чисел

function showPrimes(n) {
  //
  for (let i = 2; i < n; i++) {
    //
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue;
    }

    alert(i);
  }
}

// как ее комментировать
//1. можно комменты заносить в код , в циклах внутри.
// лучше каждый шаг- строку, чем одну строку про все вверху, над ф-цией

//2. лучше не делать цикл в цикле.
// если 2 for - лучш5е сделать 2мя прямыми ф - циями.и одна ф - ция вызывает 2 - ю ф - цию
// поддерживать for в for-e неудобно
// делайте много маленьких ф-циф. одна ф-я - одно действие
// Название ф-ции отвечает тому, что делает эта ф-я

// ----------------
// 25:25 мин
// как приавильнее и что описывать
//
// Не давать описание компонентов высокого уровня, как они взаимодействуют,
// что они делают в разных обстоятельствах
// @paran { number } X число,
//
// есть спец синтаксис (для документации ф-ций)
//см.  7-синтаксис для комментов.png
// // https://uk.wikipedia.org/wiki/JSDoc
// Синтаксис

// Частини, що належать до JSDoc документації, зазвичай розміщуються в контейнері, який починається з символів /** та закінчується */.
// Теги
//     Тег 	Опис
//     @author 	Ім'я розробника.
//     @constructor 	Позначає функцію як конструктор.
//     @param 	Документування параметра.
//     @return 	Документування результату, що повертає функція.
//     @see 	Документування асоціації з іншим об'єктом.
// @version 	Вказує номер версії бібліотеки.

//     Приклад використання

//  /**
//   * Create an instance of Circle.
//   *
//   * @constructor
//   * @param {number} r The desired radius of the circle.
//   */
//   function Circle(r) {
//   }

// @param {number} N возведет в степень
// таки комменты позволяют понять цель ф - ции
// какиепараметры относительно чего..
//
// Итого ппо комментариям:-----
//1. что надо комментировать -  ------
//   общую архитектуру высокого уровня,
//   использвание ф - ций
// важные решения , если они неочевидны
//
//2. что НЕнадо описывать -  --------
// весь код, что делает
// Описывать код надо только в том случае, если его сложно  понять .
// Если сложная ф - ция, которую надо комментирвоать - думайте, как переписать.чтобы написать проще ф - цию.
// написать ее в нескольких ф-циях и чт оне требует тогда должгих описаний
//
//3. испоьзуем спецификацию документирования ф-ций -  --------
// // https://uk.wikipedia.org/wiki/JSDoc

// 27:12 мин
// ============================================
// фигурные скобки в функциях
// ============================================
//1. многострочность- однострочность ============================================
if (a === 5) {
}

// фигурная скобка открывается не на новой скобке, а в 1-й же строке использования, рядом с предыдущим первы текстом ф-ции
// так красивее, правильнее и читабильнее.
// Бывают ф-ции в 1 строку
// if (a === 5) {   console.log("ok"); }
// prettier переделывает такое в многострочную.
if (a === 5) {
  console.log("ok");
}

// НО - если пишем одну строку, то фигурные скобки ненужны!!!
// если нужнно короткую запись - можно (без {}):
if (a === 5) console.log("ok");
// компилятор не ругается

// если надо разносить код на неск строчек, обязательно использовать фигурные скобки
// для сопровождения потом

// Писать в одну строку можно, это нормально . Но лучше- писать с фигурными в неск строк
// так понятнее и читабильнее
if (a === 5) {
  console.log("ok");
}

//2. переменные с большим текстом==============================================
// 28:38 мин
const text =
  "ljh kjh ;kh ;khj ;jb ;kb ;hkb ;hb ;ubg;ihv gguc lugcv ljh kjh ;kh ;khj ;jb ;kb ;hkb ;hb ;ubg;ihv gguc lugcv ljh kjh ;kh ;khj ;jb ;kb ;hkb ;hb ;ubg;ihv gguc lugcv ";

//по хорошей практике длина строки д.б. 80-120 символов
//лучше текст переносить.
// Для этого есть кавычки обратные ``
//так можно переносить сколько надо.
const text2 = `ljh kjh ;kh ;khj ;jb ;kb ;hkb ;hb
   ;ubg;ihv gguc lugcv ljh kjh ;kh ;khj ;jb
    ;kb ;hkb ;hb ;ubg;ihv gguc lugcv ljh kjh ;kh ;khj ;jb
     ;kb ;hkb ;hb ;ubg;ihv gguc lugcv `;
// это чтобы было читабильнее длинный текст
//вмещать в экран

// тоже про длинные if -----------------------
// переносить надо (если много через and условий)
// if ( a === 6 &&   d === g &&   m === "jhg kjgkghvfkhgfkhgfhkgfkhgfkghf f ghkf" &&  g === "jhg kjgkghvfkhgfkhgfhkgfkhgfkg")
// надо переносить.
//само перенесло при сохранении (prettier)
// Для читабельности , сопровождения
if (
  a === 6 &&
  d === g &&
  m === "jhg kjgkghvfkhgfkhgfhkgfkhgfkghf f ghkf" &&
  g === "jhg kjgkghvfkhgfkhgfhkgfkhgfkg"
) {
  console.log("dg");
}

// 30:54 мин
// отступы =======================
// горизонтальные  отступы----------------
// если много параметров
// param (ljhnkjhkj, kjhkjh, lkjlkjlk )
// выравнивать
// param(ljhnkjhkj,
//       kjhkjh,
//       lkjlkjlk);
//
// вертикальные  отступы----------------
// в функциях
// перед новым for - пустая строка
//логические отступы для читабельности кода
// if (true) {
//   console.log("ok");

//   for ()

//     for()
// }

// 32:05 мин
// точки с запятой--------------
// не забывать
// если есть prettier - будет ok

// избегать большого уровня вложений

// если делим ф-ции на несколько помельче
// Как их лучше объявить
// пример:
// Есть такие ф-ции
function createElem() {}

function useElem() {}

function useElem() {}
//есть ф-ция, которая их все 3 использует
let elem = createElem();
useElem();
useElem();

// правильное оформление:
// или сначала все ф-ции, потом ту, ктотраяи их использует
// или наоборот.
// Но - не вперемешку.

// 33:38 мин
// ========================================
// есть пособия по стилю кода
// 7_пособие по стилю кода.png
// https://google.github.io/styleguide/jsguide.html
//правила - как писать код, какие кавычки, сколько пробелов
// максимальная длина
//там все подробно.

// 34:05 мин
// ========================================
// еще по стилю каод
// есть помощники линтеры
// js - lint  старый, самый первый
// es - lint - самый популярный
// Чаще он уже установлен в проекте
// Пока es-linter выдаепт ошибки, это мешает загрузить (Push) свой код.
// Поэтому для хорошей практики установить ESLint в свой проектик и делать с ним

// на след.уроках будет - как устанавливать node, библиотекм
// По стандартам- пока все--------------------------

// 34:50 мин
// ========================================
// ошибки в оформлении кода

//1. написать ф-цию коротко (тернарник?...)-----------
// Условный(тернарный) оператор - единственный оператор в JavaScript,
//  принимающий три операнда: условие, за которым следует знак вопроса(?)

// i = i ? i ? < 0 ? Math.max(0, i++) : 1 : 0

// нечитабильно. но рабочая.
// Лучше писать switch case...
// не делать большие тернарники

// 34:50 мин
//3. однобуквенные переменные не использовать -----------
// Писать смысловую переменную
// function a() {
//   const b;
// }

//4.  -----------
// Не использовать аббревиатуры,
//   list - lst одну букву сокращать не имеет смысла
// accumulator - можно сокращаать, слово длинное.

//5.  -----------
// в названиях переменных не использовать Data, Item, Value(если онон невнутри названия)
// data1, data2 тоже ненадо

// const user = {};
// function userChange() {
//   let user = "";
// }

// Да, user внутри виден, норм. Но вчитываться надо, чтобы понять.

//6.  -----------
// Когда загружаем(push) код в проект и много вкладок в структуре проекта(в меню слева в VScode)
// в чужих файлах , если не меняли ничего - новые пустые строки , enter, пробелы  не добавлять
// загружать только тот свой файл, где что-то писали сами

// 39: 44 мин
// ИТОГО за 2 урока:============================
// говорили про
// замыкание
// классы
// объекты
// ооп
// 4 свойства ооп
// прототипы
// стандарты оформления кода
